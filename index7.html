<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Super Jerry – Double-Jump & Moving Stairs</title>
  <style>
    html, body {
      margin:0; padding:0;
      user-select:none;
      display:flex; flex-direction:column;
      align-items:center;
      background:#eef;
    }
    #game-container {
      position:relative;
      width:800px; height:600px;
      border:4px solid #333;
      overflow:hidden;
      background:#87ceeb;
      margin:20px auto;
    }
    #canvas {
      width:800px; height:600px; display:block;
    }
    #restart {
      position:absolute; top:50%; left:50%;
      transform:translate(-50%,-50%);
      padding:10px 20px; font-size:18px;
      display:none; z-index:10;
    }
    #controls {
      width:800px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:10px;
    }
    #joystick-container {
      width:240px; height:240px;
      border-radius:50%;
      background:rgba(0,0,0,0.25);
      touch-action:none;
      position:relative;
    }
    #joystick-thumb {
      position:absolute;
      width:80px; height:80px;
      border-radius:50%;
      background:rgba(0,0,0,0.5);
      left:calc(50% - 40px);
      top:calc(50% - 40px);
      transition:left .1s, top .1s;
    }
    #fire-button {
      width:80px; height:80px;
      border-radius:50%;
      background:rgba(0,0,255,0.6);
      color:white; font-size:14px;
      border:none; touch-action:none;
    }
  </style>
</head>
<body>
  <h1>SUPER JERRY RUNNER</h1>
  <h3>Now with Moving Stairs, Coins & Shooting!</h3>
  <div style="display:flex; gap:10px; margin-bottom:10px;">
    <button onclick="window.location.href='index.html'">Arrow keys</button>
    <button onclick="window.location.href='index2.html'">Joystick</button>
    <button onclick="window.location.href='index3.html'">Joystick + Fire</button>
    <button onclick="window.location.href='index4.html'">Long Stage</button>
    <button onclick="window.location.href='index5.html'">Jump + Fire</button>
    <button onclick="window.location.href='index6.html'">Jump + Stairs</button>
    <button onclick="window.location.href='index7.html'">Snake + Mario</button>
  </div>
  <div id="game-container">
    <canvas id="canvas" width="800" height="600"></canvas>
    <button id="restart">Restart</button>
  </div>
  <div id="controls">
    <div id="joystick-container"><div id="joystick-thumb"></div></div>
    <button id="fire-button">FIRE</button>
  </div>

  <script>
  window.onload = () => {
    const canvas = document.getElementById("canvas"),
          ctx = canvas.getContext("2d"),
          restartBtn = document.getElementById("restart"),
          fireBtn = document.getElementById("fire-button"),
          base = document.getElementById("joystick-container"),
          thumb = document.getElementById("joystick-thumb");

    const viewW = 800, viewH = 800;
    const worldW = 5000, worldH = viewH;
    const floorHeight = 50;
    const ladderRise = 250;
    let currentFloor = 0;
    const totalFloors = 50;
    const gridSize = 50;  // size of each square on the floor surface
    // Total world height = one screen + extra height for each additional floor
const worldHeight = viewH + ladderRise * (totalFloors - 1);
// Maximum camera Y‐offset so we never scroll below the ground or above the top floor
const maxCamY     = worldHeight - viewH;

 function getFloorY(floor) {
  return worldH - floorHeight - ladderRise * floor;
}

const floorY = worldHeight - floorHeight - ladderRise * currentFloor;

    const playerSize = 50;
    let x = 100, y = worldH - floorHeight - playerSize;
    let vx = 0, vy = 0;
    let grounded = false, jumpsRemaining = 2, gameOver = false;

    const accel = 2000;
    const gravity = 2000;
    const jumpVelocity = 750;
    const joyBoost = 1.5;
    const runMultiplier = 1.8;
    const horizontalFric = 0.85;
    const verticalFric = 1.0;

    const coinSize = 35, coins = [], numCoins = 10;
    const obstacleSize = coinSize;
    const groundObs = [], numGroundObs = 8;
    const fallingObs = [], numFallingObs = 8;
    const stairs = [], stairW = 120, stairH = 20, numStairs = 4;

    const bullets = [];
    const bulletSpeed = 1000;
    const bulletSize = 8;

    let score = 0;
    const keys = {};

    for (let i = 0; i < numCoins; i++) {
  const floor = i % totalFloors;
  coins.push({
    x: rand(300, worldW - coinSize - 200),
    y: worldH - floorHeight - ladderRise * floor - coinSize - rand(0, 80)
  });
}


    document.addEventListener("keydown", e => {
      keys[e.key.toLowerCase()] = true;
      if ((e.key === "w" || e.key === "ArrowUp") && jumpsRemaining > 0) {
        vy = -jumpVelocity;
        jumpsRemaining--;
        grounded = false;
      }
      if (e.code === "Space") shootBullet();
    });

    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    let joyX = 0, joyY = 0;
    const stickR = 120, thumbR = 40, maxDisp = stickR - thumbR;
    base.addEventListener("touchstart", e => e.preventDefault(), { passive: false });
    base.addEventListener("touchmove", e => {
      const t = e.touches[0], r = base.getBoundingClientRect();
      let dx = t.clientX - (r.left + stickR),
          dy = t.clientY - (r.top + stickR),
          d = Math.hypot(dx, dy);
      if (d > maxDisp) { dx = dx / d * maxDisp; dy = dy / d * maxDisp; }
      thumb.style.left = `${stickR + dx - thumbR}px`;
      thumb.style.top = `${stickR + dy - thumbR}px`;
      joyX = dx / maxDisp; joyY = dy / maxDisp;
      e.preventDefault();
    }, { passive: false });

    base.addEventListener("touchend", handleEnd);
    base.addEventListener("touchcancel", handleEnd);

    function handleEnd() {
      thumb.style.left = "calc(50% - 40px)";
      thumb.style.top = "calc(50% - 40px)";
      joyX = joyY = 0;
    }

    fireBtn.addEventListener("touchstart", e => { e.preventDefault(); shootBullet(); });
    fireBtn.addEventListener("mousedown", e => { e.preventDefault(); shootBullet(); });

    function shootBullet() {
      // reuse your old shooting logic here if needed
    }

    function initEntities() {
      coins.length = groundObs.length = fallingObs.length = stairs.length = 0;
      for (let i = 0; i < numCoins; i++) {
        coins.push({ x: rand(300, worldW - coinSize - 200), y: worldH - floorHeight - coinSize - rand(0, 80) });
      }
    }

    function rand(min, max) { return Math.random() * (max - min) + min; }
    function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
    function overlap(x1, y1, w1, h1, x2, y2, w2, h2) {
      return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;
    }

   
// const floorY = getFloorY(currentFloor);



//  function climbLadder() {
//   gameOver = true;
//   setTimeout(() => {
//     currentFloor++;
//     if (currentFloor >= 10) {
//       alert("You win!");
//       return;
//     }
//     x = (currentFloor % 2 === 0) ? 0 : worldW - playerSize;
//     y = getFloorY(currentFloor) - playerSize;
//     vx = vy = 0;
//     gameOver = false;
//   }, 150);
// }



    function draw() {
      const now = Date.now(), dt = (now - lastTime) / 1000;
      lastTime = now;
      const gridSize       = 50;    // size of each square
const parallaxFactor = 0.3;   // 0 = static background, 1 = same speed as world


      let ax = 0;
      if ((keys["d"] || keys["arrowright"])) {
        // ax += (currentFloor % 2 === 0 ? accel : -accel) * runMultiplier;
        ax += accel * runMultiplier;
      }
      if ((keys["a"] || keys["arrowleft"])) {
        // ax -= (currentFloor % 2 === 0 ? accel : -accel) * runMultiplier;
        ax -= accel * runMultiplier;
      }
      ax += joyX * accel * joyBoost * runMultiplier;
      vx += ax * dt;
      vx *= horizontalFric;

      if (joyY < -0.5 && jumpsRemaining > 0) {
        vy = -jumpVelocity;
        jumpsRemaining--;
        grounded = false;
      }
      vy += gravity * dt;
      vy *= verticalFric;

      x += vx * dt;
      y += vy * dt;

      const floorY = worldH - floorHeight - ladderRise * currentFloor;

      grounded = false;
      if (y + playerSize >= floorY) {
        y = floorY - playerSize;
        vy = 0;
        grounded = true;
        jumpsRemaining = 2;
      }
if (!gameOver) {
  const atEdge = (currentFloor % 2 === 0)
    ? x + playerSize >= worldW
    : x <= 0;
  if (atEdge) {
    currentFloor++;
    if (currentFloor >= totalFloors) {
      alert("You win!");
    } else {
      x = (currentFloor % 2 === 0) ? 0 : worldW - playerSize;
      y = worldH - floorHeight - ladderRise*currentFloor - playerSize;
      vx = vy = 0;
    }
  }
}

      // const camX = clamp(x + playerSize / 2 - viewW / 2, 0, worldW - viewW);
      const camX = clamp(
  x + playerSize/2 - viewW/2,
  0,
  worldW - viewW
);
const camY = clamp(
  y + playerSize/2 - viewH/2,   // center on player’s vertical position
  0,                             // can’t scroll below ground
  worldHeight - viewH            // can’t scroll above top floor
);



      // vertical camera: floor-0 stays bottom-aligned, floor-1+ centered
// let camY = 0;
// if (currentFloor > 0) {
//   const fy = getFloorY(currentFloor); 
//   // center that floor vertically
//   camY = clamp(
//     fy - (viewH/2 - floorHeight/2),
//     0,
//     worldH - viewH
//   );
// }

// ─── NEW: vertical camera offset ──────────────────
// center the player (or current floor) vertically
// const camY = clamp(
//   y + playerSize/2 - viewH/2,      // aim to center player in view
//   0,                                // don’t scroll below ground
//   worldHeight - viewH               // don’t scroll past top floor
// );


      ctx.clearRect(0, 0, viewW, viewH);

      // draw parallax grid
const bgOffset = camX * parallaxFactor;
ctx.save();
ctx.translate(-bgOffset, 0);
ctx.strokeStyle = "rgba(255,255,255,0.2)";
ctx.lineWidth = 1;

// vertical lines
for (let gx = 0; gx <= viewW + gridSize; gx += gridSize) {
  ctx.beginPath();
  ctx.moveTo(gx, 0);
  ctx.lineTo(gx, viewH);
  ctx.stroke();
}

// horizontal lines
for (let gy = 0; gy <= viewH + gridSize; gy += gridSize) {
  ctx.beginPath();
  ctx.moveTo(0, gy);
  ctx.lineTo(viewW + gridSize, gy);
  ctx.stroke();
}

ctx.restore();

      ctx.save();
      ctx.translate(-camX, -camY);

      ctx.fillStyle = "#654321";
      ctx.fillRect(0, floorY, worldW, floorHeight);

      if (currentFloor === 0) {
        const ladderX = worldW - 40;
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(ladderX + 5, floorY);
        ctx.lineTo(ladderX + 5, floorY - ladderRise);
        ctx.moveTo(ladderX + 35, floorY);
        ctx.lineTo(ladderX + 35, floorY - ladderRise);
        ctx.stroke();
        for (let yy = floorY; yy >= floorY - ladderRise; yy -= 20) {
          ctx.beginPath();
          ctx.moveTo(ladderX + 5, yy);
          ctx.lineTo(ladderX + 35, yy);
          ctx.stroke();
        }
      }

      coins.forEach((c, i) => {
        ctx.drawImage(coinImg, c.x, c.y, coinSize, coinSize);
        if (overlap(c.x, c.y, coinSize, coinSize, x, y, playerSize, playerSize)) {
          score++;
          coins.splice(i, 1);
        }
      });

      ctx.drawImage(playerImg, x, y, playerSize, playerSize);
      // inside draw(), after ctx.translate(-camX, 0):
for (let i = 0; i < totalFloors; i++) {
  const fy = getFloorY(i);

  // 1) Draw floor base
  ctx.fillStyle = "#654321";
  ctx.fillRect(0, fy, worldW, floorHeight);

  // 2) Grid on floor “roof”
  ctx.strokeStyle = "rgba(0,0,0,0.2)";
  ctx.lineWidth = 1;
  // vertical lines
  for (let gx = 0; gx <= worldW; gx += gridSize) {
    ctx.beginPath();
    ctx.moveTo(gx, fy);
    ctx.lineTo(gx, fy + floorHeight);
    ctx.stroke();
  }
  // horizontal lines
  for (let gy = fy; gy <= fy + floorHeight; gy += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, gy);
    ctx.lineTo(worldW, gy);
    ctx.stroke();
  }

  // 3) Ladder rails
  const ladderX = (i % 2 === 0 ? worldW - 40 : 0);
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(ladderX + 5, fy);
  ctx.lineTo(ladderX + 5, fy - ladderRise);
  ctx.moveTo(ladderX + 35, fy);
  ctx.lineTo(ladderX + 35, fy - ladderRise);
  ctx.stroke();

  // 4) Ladder rungs
  for (let yy = fy; yy >= fy - ladderRise; yy -= 20) {
    ctx.beginPath();
    ctx.moveTo(ladderX + 5, yy);
    ctx.lineTo(ladderX + 35, yy);
    ctx.stroke();
  }
}


// if (!gameOver) {
//   const atRightEdge = x + playerSize >= worldW;
//   const atLeftEdge = x <= 0;
//   if (currentFloor % 2 === 0 && atRightEdge) {
//     climbLadder();
//   } else if (currentFloor % 2 !== 0 && atLeftEdge) {
//     climbLadder();
//   }
// }



      ctx.restore();

      ctx.fillStyle = "black";
      ctx.font = "25px Arial";
      ctx.fillText("Score: " + score, 10, 30);

      if (!gameOver) requestAnimationFrame(draw);
    }

    restartBtn.onclick = () => {
      x = 100;
      y = worldH - floorHeight - playerSize;
      vx = vy = 0;
      grounded = true;
      jumpsRemaining = 2;
      gameOver = false;
      score = 0;
      currentFloor = 0;
      bullets.length = 0;
      initEntities();
      restartBtn.style.display = "none";
      lastTime = Date.now();
      requestAnimationFrame(draw);
    };

    const playerImg = new Image(), coinImg = new Image(), bombImg = new Image();
    playerImg.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS2oP3lWLmezhBAmuHvAwuaqRv6xVX0eApt7A&s';
        coinImg.src = 'https://www.partysuppliesindia.com/cdn/shop/products/1_36_9f92dde3-d77d-4459-a21f-63744a94c836.jpg?v=1735574298&width=1500';
    bombImg.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSrhGLUu7GF58R8WurYsZXGRwPSg1aER4LGrw&s';

    let lastTime = Date.now();

    playerImg.onload = () => {
      coinImg.onload = () => {
        bombImg.onload = () => {
          initEntities();
          lastTime = Date.now();
          draw();
        };
      };
    };
  };
</script>

  
</body>
</html>
