<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Super Jerry – Double-Jump & Moving Stairs</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            margin:0; padding:0;
            user-select:none;
            display:flex; flex-direction:column;
            align-items:center;
            background:#eef;
            font-family: 'Inter', sans-serif; /* Added Inter font */
        }
        h1, h3 {
            color: #334155; /* Tailwind slate-700 */
        }
        #game-container {
            position:relative;
            width:800px; height:600px; /* Fixed height for consistency */
            border:4px solid #333;
            overflow:hidden;
            background:#87ceeb;
            margin:20px auto;
            border-radius: 0.5rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Shadow */
        }
        #canvas {
            width:800px; height:600px; display:block;
        }
        /* Restart button (red gradient, bigger) */
#restart {
  font-size: 20px;
  padding: 14px 32px;      /* Larger tap target */
  border-radius: 10px;
  font-weight: 600;
  color: white;
  background: linear-gradient(145deg, #f87171, #ef4444);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  border: none;
  display: none;
  z-index: 10;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: all 0.2s ease-in-out;
}

#restart:hover {
  background: linear-gradient(145deg, #ef4444, #dc2626);
  transform: translate(-50%, -50%) translateY(-2px);
  box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
}

#restart:active {
  transform: translate(-50%, -50%) translateY(0);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
        button {
            cursor: pointer;
            font-family: inherit;
            border: none;
            outline: none;
        }
        #controls {
            width:800px;
            display:flex;
            justify-content:space-between;
            align-items:center;
            margin-bottom:10px;
        }
        /* Menu buttons (blue gradient) */
.control-button {
  font-size: 18px;
  padding: 14px 28px;       /* Bigger size */
  border-radius: 8px;
  font-weight: 600;
  color: white;
  background: linear-gradient(145deg, #60a5fa, #3b82f6);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  margin: 5px;
  transition: all 0.2s ease-in-out;
}

.control-button:hover {
  background: linear-gradient(145deg, #3b82f6, #2563eb);
  transform: translateY(-2px);
  box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
}

.control-button:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
        #joystick-container {
            width:120px; height:120px; /* Made smaller for better mobile fit */
            border-radius:50%;
            background:rgba(0,0,0,0.25);
            touch-action:none;
            position:relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        #joystick-thumb {
            position:absolute;
            width:40px; height:40px; /* Made smaller */
            border-radius:50%;
            background:rgba(0,0,0,0.5);
            left:calc(50% - 20px); /* Center dynamically */
            top:calc(50% - 20px); /* Center dynamically */
            transition:none; /* Removed transition for immediate response */
        }
        #fire-button {
            width:70px; height:70px; /* Made smaller */
            border-radius:50%;
            background:rgba(0,0,255,0.6);
            color:white; font-size:14px;
            border:none; touch-action:none;
            @apply font-semibold; /* Apply Tailwind font styles */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #fire-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Responsive adjustments */
        @media (max-width: 820px) {
            #game-container, #controls {
                width: 95%; /* Make container fluid */
                margin-left: auto;
                margin-right: auto;
            }
            #canvas {
                width: 100%; /* Canvas takes full width of container */
                height: auto; /* Maintain aspect ratio */
            }
            body {
                padding: 0.5rem;
            }
            .control-button {
                font-size: 0.8rem;
                padding: 0.5rem 1rem;
            }
            #joystick-container {
                width: 100px;
                height: 100px;
            }
            #joystick-thumb {
                width: 30px;
                height: 30px;
                left:calc(50% - 15px);
                top:calc(50% - 15px);
            }
            #fire-button {
                width: 60px;
                height: 60px;
                font-size: 12px;
            }
        }
        
    </style>
</head>
<body>
    <h1>SUPER JERRY RUNNER</h1>
    <h3>Now with Moving Stairs, Coins & Shooting!</h3>
    <div style="display:flex; gap:10px; margin-bottom:10px;">
        <button onclick="window.location.href='index.html'" class="control-button">Home</button>
        <button onclick="window.location.href='index.html'" class="control-button">Other Gamea</button>
        <!-- <button onclick="window.location.href='index1.html'" class="control-button">Arrow keys</button>
        <button onclick="window.location.href='index2.html'" class="control-button">Joystick</button>
        <button onclick="window.location.href='index3.html'" class="control-button">Joystick + Fire</button>
        <button onclick="window.location.href='index4.html'" class="control-button">Long Stage</button>
        <button onclick="window.location.href='index5.html'" class="control-button">Jump + Fire</button>
        <button onclick="window.location.href='index6.html'" class="control-button">Jump + Stairs</button>
        <button onclick="window.location.href='index7.html'" class="control-button">Snake + Mario</button> -->
    </div>
    <div id="game-container">
        <canvas id="canvas" width="800" height="600"></canvas>
        <button id="restart">Restart</button>
    </div>
    <div id="controls">
        <div id="joystick-container"><div id="joystick-thumb"></div></div>
        <button id="fire-button">FIRE</button>
    </div>

    <script>
        window.onload = () => {
            const canvas = document.getElementById("canvas"),
                ctx = canvas.getContext("2d"),
                restartBtn = document.getElementById("restart"),
                fireBtn = document.getElementById("fire-button"),
                base = document.getElementById("joystick-container"),
                thumb = document.getElementById("joystick-thumb");

            const viewW = 800, viewH = 600;
            const worldW = 5000;
            const floorHeight = 50;
            const ladderRise = 350;
            let currentFloor = 0;
            const totalFloors = 50;
            const gridSize = 50;

            function getFloorY(floor) {
                return canvas.height - floorHeight - ladderRise * floor;
            }

            const playerSize = 50;
            let x = 100, y = getFloorY(0) - playerSize;
            let vx = 0, vy = 0;
            let grounded = false, jumpsRemaining = 2, gameOver = false;

            const accel = 2000;
            const gravity = 2000;
            const bombFallSpeed = 200; // Slower speed for bombs (Decreased from 500 to 200)
            const jumpVelocity = 750;
            const joyBoost = 1.5;
            const runMultiplier = 1.8;
            const horizontalFric = 0.85;
            const verticalFric = 1.0;

            const coinSize = 35, coins = [], numCoins = 10;
            const obstacleSize = 40; // Size for moving enemies
            const movingEnemies = []; // No fixed numMovingEnemies, populated per floor
            const fallingBombSize = 35; // Size for falling bombs
            const fallingBombs = [], numFallingBombs = 5;
            const stairW = 120, stairH = 20;
            const movingStairs = [], numMovingStairs = 5; // Increased number of moving stairs

            const bullets = [];
            const bulletSpeed = 1000;
            const bulletSize = 8;

            let score = 0;
            const keys = {};

            // Helper functions
            function rand(min, max) { return Math.random() * (max - min) + min; }
            function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
            function overlap(x1, y1, w1, h1, x2, y2, w2, h2) {
                return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;
            }

            // Initialize game entities
            function initEntities() {
                coins.length = 0;
                movingEnemies.length = 0;
                fallingBombs.length = 0;
                bullets.length = 0; // Clear bullets on restart
                movingStairs.length = 0; // Clear moving stairs on restart

                for (let i = 0; i < numCoins; i++) {
                    const floor = i % totalFloors;
                    coins.push({
                        x: rand(300, worldW - coinSize - 200),
                        y: getFloorY(floor) - coinSize - rand(0, 80)
                    });
                }

                // Populate 3 moving enemies for EACH floor
                for (let floorIdx = 0; floorIdx < totalFloors; floorIdx++) {
                    for (let i = 0; i < 3; i++) { // 3 enemies per floor
                        movingEnemies.push({
                            x: rand(100, worldW - obstacleSize - 100),
                            y: getFloorY(floorIdx) - obstacleSize,
                            width: obstacleSize,
                            height: obstacleSize,
                            vx: rand(100, 200) * (Math.random() < 0.5 ? 1 : -1), // Random direction
                            color: `hsl(${rand(0, 360)}, 70%, 50%)` // Random color
                        });
                    }
                }

                for (let i = 0; i < numFallingBombs; i++) {
                    fallingBombs.push({
                        x: rand(0, worldW - fallingBombSize),
                        y: rand(-500, -50), // Start above the screen
                        size: fallingBombSize,
                        vy: 0 // Initial vertical velocity
                    });
                }

                // New: Initialize moving stairs - position them higher above the floor
                for (let i = 0; i < numMovingStairs; i++) {
                    const floor = Math.floor(rand(0, totalFloors));
                    movingStairs.push({
                        x: rand(100, worldW - stairW - 100), // Ensure it fits on the floor
                        y: getFloorY(floor) - stairH - rand(50, 100), // Position it higher above the floor (increased buffer)
                        width: stairW,
                        height: stairH,
                        vx: rand(80, 180) * (Math.random() < 0.5 ? 1 : -1), // Random speed and direction
                    });
                }
            }

            document.addEventListener("keydown", e => {
                keys[e.key.toLowerCase()] = true;
                if ((e.key === "w" || e.key === "ArrowUp") && jumpsRemaining > 0) {
                    vy = -jumpVelocity;
                    jumpsRemaining--;
                    grounded = false;
                }
                if (e.code === "Space") shootBullet();
            });

            document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

            let joyX = 0, joyY = 0;
            const stickR = 60, thumbR = 20, maxDisp = stickR - thumbR;
            base.addEventListener("touchstart", e => e.preventDefault(), { passive: false });
            base.addEventListener("touchmove", e => {
                const t = e.touches[0], r = base.getBoundingClientRect();
                let dx = t.clientX - (r.left + stickR),
                    dy = t.clientY - (r.top + stickR),
                    d = Math.hypot(dx, dy);
                if (d > maxDisp) { dx = dx / d * maxDisp; dy = dy / d * maxDisp; }
                thumb.style.left = `${stickR + dx - thumbR}px`;
                thumb.style.top = `${stickR + dy - thumbR}px`;
                joyX = dx / maxDisp; joyY = dy / maxDisp;
                e.preventDefault();
            }, { passive: false });

            base.addEventListener("touchend", handleEnd);
            base.addEventListener("touchcancel", handleEnd);

            function handleEnd() {
                thumb.style.left = "calc(50% - 20px)";
                thumb.style.top = "calc(50% - 20px)";
                joyX = joyY = 0;
            }

            fireBtn.addEventListener("touchstart", e => { e.preventDefault(); shootBullet(); });
            fireBtn.addEventListener("mousedown", e => { e.preventDefault(); shootBullet(); });

            function shootBullet() {
                // Ensure the player is facing a direction to shoot
                bullets.push({
                    x: x + playerSize / 2,
                    y: y + playerSize / 2,
                    vx: (keys["d"] || keys["arrowright"] || joyX > 0) ? bulletSpeed : -bulletSpeed, // Shoot in player's current horizontal direction
                    vy: 0,
                    size: bulletSize
                });
            }

            function gameLoop() {
                const now = Date.now(), dt = (now - lastTime) / 1000;
                lastTime = now;
                const parallaxFactor = 0.3;

                let ax = 0;
                if ((keys["d"] || keys["arrowright"])) {
                    ax += accel * runMultiplier;
                }
                if ((keys["a"] || keys["arrowleft"])) {
                    ax -= accel * runMultiplier;
                }
                ax += joyX * accel * joyBoost * runMultiplier;
                vx += ax * dt;
                vx *= horizontalFric;

                if (joyY < -0.5 && jumpsRemaining > 0) {
                    vy = -jumpVelocity;
                    jumpsRemaining--;
                    grounded = false;
                }
                vy += gravity * dt;
                vy *= verticalFric;

                // Player position update based on its own velocity
                x += vx * dt;
                y += vy * dt;

                let appliedStairVx = 0; // Velocity to add from a moving stair
                grounded = false; // Reset grounded state each frame

                // Check collision with moving stairs first (as they provide temporary ground)
                for (let i = 0; i < movingStairs.length; i++) {
                    const stair = movingStairs[i];
                    // Update stair position
                    stair.x += stair.vx * dt;
                    // Reverse direction if hitting world boundaries
                    if (stair.x <= 0 || stair.x + stair.width >= worldW) {
                        stair.vx *= -1;
                    }

                    // Check if player is on the stair or just landed on it
                    // The `vy >= 0` ensures player is falling or stable, not jumping up through the stair
                    // The `y + playerSize - (vy * dt)` checks player's previous frame position for landing
                    if (overlap(x, y, playerSize, playerSize, stair.x, stair.y, stair.width, stair.height) &&
                        vy >= 0 && (y + playerSize - (vy * dt)) <= stair.y) {
                        y = stair.y - playerSize; // Snap player to the top of the stair
                        vy = 0; // Stop vertical movement
                        grounded = true;
                        jumpsRemaining = 2;
                        appliedStairVx = stair.vx; // Apply stair's horizontal velocity to player
                        break; // Player is on this stair, stop checking others
                    }
                }

                // If not grounded on a moving stair, check for collision with the main floor
                if (!grounded) {
                    const currentFloorGroundY = getFloorY(currentFloor);
                    if (y + playerSize >= currentFloorGroundY) {
                        y = currentFloorGroundY - playerSize;
                        vy = 0;
                        grounded = true;
                        jumpsRemaining = 2;
                    }
                }

                // Apply the stair's velocity to the player's X position AFTER all other horizontal movements
                // This is done after player's own vx is applied, so it adds to player's movement.
                x += appliedStairVx * dt;


                // --- Player transitioning between floors ---
                if (!gameOver) {
                    const ladderXAtCurrentFloor = (currentFloor % 2 === 0) ? worldW - 40 : 0;
                    const ladderWidth = 40;
                    
                    // If player reaches the horizontal edge of the current floor, move to the next floor
                    const atEdge = (currentFloor % 2 === 0)
                        ? x + playerSize >= worldW - 20 // Reaching right edge for even floors
                        : x <= 20; // Reaching left edge for odd floors

                    // Simplified condition for floor transition: only check if at the correct horizontal edge
                    if (atEdge) { 
                        currentFloor++;
                        if (currentFloor >= totalFloors) {
                            const messageDiv = document.createElement('div');
                            messageDiv.style.cssText = `
                                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                background: #4caf50; color: white; padding: 20px; border-radius: 8px;
                                box-shadow: 0 4px 10px rgba(0,0,0,0.2); z-index: 1000; text-align: center;
                            `;
                            messageDiv.innerText = "You win!";
                            document.body.appendChild(messageDiv);
                            setTimeout(() => messageDiv.remove(), 2000);
                            gameOver = true;
                        } else {
                            // Reset player position for the new floor
                            x = (currentFloor % 2 === 0) ? 0 : worldW - playerSize;
                            y = getFloorY(currentFloor) - playerSize;
                            vx = vy = 0;
                        }
                    }
                }

                // --- Update Moving Enemies ---
                movingEnemies.forEach(enemy => {
                    enemy.x += enemy.vx * dt;
                    // Reverse direction if hitting world boundaries
                    if (enemy.x <= 0 || enemy.x + enemy.width >= worldW) {
                        enemy.vx *= -1;
                    }

                    // Player collision with moving enemies
                    if (overlap(x, y, playerSize, playerSize, enemy.x, enemy.y, enemy.width, enemy.height)) {
                        gameOver = true;
                        restartBtn.style.display = "block";
                    }
                });

                // --- Update Falling Bombs ---
                fallingBombs.forEach(bomb => {
                    bomb.y += bomb.vy * dt;
                    bomb.vy += bombFallSpeed * dt; // Use bombFallSpeed for bombs
                    // Reset bomb if it falls off screen
                    if (bomb.y > canvas.height) { // If it falls off the visible screen (bottom)
                        bomb.y = rand(-500, -50); // Reset to a random position above screen
                        bomb.x = rand(0, worldW - bomb.size);
                        bomb.vy = 0; // Reset velocity
                    }

                    // Player collision with falling bombs
                    if (overlap(x, y, playerSize, playerSize, bomb.x, bomb.y, bomb.size, bomb.size)) {
                        gameOver = true;
                        restartBtn.style.display = "block";
                    }
                });

                // --- Update Bullets ---
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    bullet.x += bullet.vx * dt;
                    bullet.y += bullet.vy * dt;

                    // Remove bullet if off-screen
                    if (bullet.x > worldW || bullet.x < 0 || bullet.y > canvas.height || bullet.y < getFloorY(totalFloors - 1)) {
                        bullets.splice(i, 1);
                        continue;
                    }

                    // Bullet collision with moving enemies
                    for (let j = movingEnemies.length - 1; j >= 0; j--) {
                        const enemy = movingEnemies[j];
                        if (overlap(bullet.x, bullet.y, bullet.size, bullet.size, enemy.x, enemy.y, enemy.width, enemy.height)) {
                            score += 10; // Score for hitting an enemy
                            movingEnemies.splice(j, 1); // Remove enemy
                            bullets.splice(i, 1); // Remove bullet
                            break; // Bullet hit something, stop checking enemies for this bullet
                        }
                    }
                }


                // --- Camera calculations ---
                const camX = clamp(x + playerSize / 2 - viewW / 2, 0, worldW - viewW);
                const targetCamYOffset = (viewH / 2 - playerSize / 2) - y;
                const minAllowedCamYOffset = (viewH / 2 - playerSize / 2) - (getFloorY(totalFloors - 1) - playerSize);
                const maxAllowedCamYOffset = (viewH / 2 - playerSize / 2) - (getFloorY(0) - playerSize);
                const camY = clamp(targetCamYOffset, maxAllowedCamYOffset, minAllowedCamYOffset);

                // --- Drawing ---
                ctx.clearRect(0, 0, viewW, viewH);

                // Draw parallax grid
                const bgOffset = camX * parallaxFactor;
                ctx.save();
                ctx.translate(-bgOffset, camY);
                ctx.strokeStyle = "rgba(255,255,255,0.2)";
                ctx.lineWidth = 1;

                for (let gx = 0; gx <= viewW + gridSize; gx += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(gx, -camY);
                    ctx.lineTo(gx, -camY + viewH);
                    ctx.stroke();
                }

                for (let gy = 0; gy <= viewH + gridSize; gy += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, gy - camY);
                    ctx.lineTo(viewW + gridSize, gy - camY);
                    ctx.stroke();
                }
                ctx.restore();


                ctx.save();
                ctx.translate(-camX, camY); // Apply camera translation for game world

                // Draw all floors and ladders, and floor numbers
                for (let i = 0; i < totalFloors; i++) {
                    const fy = getFloorY(i);

                    // 1) Draw floor base
                    ctx.fillStyle = "#654321";
                    ctx.fillRect(0, fy, worldW, floorHeight);

                    // 2) Grid on floor “roof”
                    ctx.strokeStyle = "rgba(0,0,0,0.2)";
                    ctx.lineWidth = 1;
                    for (let gx = 0; gx <= worldW; gx += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(gx, fy);
                        ctx.lineTo(gx, fy + floorHeight);
                        ctx.stroke();
                    }
                    for (let gy = fy; gy <= fy + floorHeight; gy += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(0, gy);
                        ctx.lineTo(worldW, gy);
                        ctx.stroke();
                    }

                    // 3) Ladder rails
                    const ladderX = (i % 2 === 0 ? worldW - 40 : 0);
                    ctx.strokeStyle = "#000";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(ladderX + 5, fy);
                    ctx.lineTo(ladderX + 5, fy - ladderRise);
                    ctx.moveTo(ladderX + 35, fy);
                    ctx.lineTo(ladderX + 35, fy - ladderRise);
                    ctx.stroke();

                    // 4) Ladder rungs
                    for (let yy = fy; yy >= fy - ladderRise; yy -= 20) {
                        ctx.beginPath();
                        ctx.moveTo(ladderX + 5, yy);
                        ctx.lineTo(ladderX + 35, yy);
                        ctx.stroke();
                    }

                    // Draw Floor Number
                    ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
                    ctx.font = "bold 30px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    const floorNumberText = `Floor ${i}`;
                    const textX = worldW / 2;
                    const textY = fy + floorHeight / 2;
                    ctx.fillText(floorNumberText, textX, textY);
                }

                // Draw coins
                coins.forEach(c => {
                    ctx.drawImage(coinImg, c.x, c.y, coinSize, coinSize);
                });
                for (let i = coins.length - 1; i >= 0; i--) {
                    const c = coins[i];
                    if (overlap(c.x, c.y, coinSize, coinSize, x, y, playerSize, playerSize)) {
                        score++;
                        coins.splice(i, 1);
                    }
                }

                // Draw moving enemies
                movingEnemies.forEach(enemy => {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                });

                // Draw falling bombs
                fallingBombs.forEach(bomb => {
                    ctx.drawImage(bombImg, bomb.x, bomb.y, bomb.size, bomb.size);
                });

                // Draw moving stairs
                movingStairs.forEach(stair => {
                    ctx.fillStyle = "#8B4513"; // Brown color for stairs
                    ctx.fillRect(stair.x, stair.y, stair.width, stair.height);
                });

                // Draw player
                ctx.drawImage(playerImg, x, y, playerSize, playerSize);

                // Draw bullets
                bullets.forEach(bullet => {
                    ctx.fillStyle = "yellow";
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                    ctx.fill();
                });


                ctx.restore();

                // Draw score (fixed on screen)
                ctx.fillStyle = "black";
                ctx.font = "25px Arial";
                ctx.fillText("Score: " + score, 10, 30);

                if (!gameOver) requestAnimationFrame(gameLoop);
            }

            restartBtn.onclick = () => {
                x = 100;
                y = getFloorY(0) - playerSize;
                vx = vy = 0;
                grounded = true;
                jumpsRemaining = 2;
                gameOver = false;
                score = 0;
                currentFloor = 0;
                restartBtn.style.display = "none";
                initEntities(); // Re-initialize all entities for a fresh game
                lastTime = Date.now();
                requestAnimationFrame(gameLoop);
            };

            const playerImg = new Image(), coinImg = new Image(), bombImg = new Image();
            playerImg.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS2oP3lWLmezhBAmuHvAwuaqRv6xVX0eApt7A&s';
            coinImg.src = 'https://www.partysuppliesindia.com/cdn/shop/products/1_36_9f92dde3-d77d-4459-a21f-63744a94c836.jpg?v=1735574298&width=1500';
            bombImg.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSrhGLUu7GF58R8WurYsZXGRwPSg1aER4LGrw&s';

            let lastTime = Date.now();

            playerImg.onload = () => {
                coinImg.onload = () => {
                    bombImg.onload = () => {
                        initEntities(); // Initial setup of entities when images are loaded
                        lastTime = Date.now();
                        gameLoop(); // Start the game loop
                    };
                };
            };
        };
    </script>
</body>
</html>
