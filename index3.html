<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dual Joystick Shooter (Fixed)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      min-height: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      background: #f0f0f0;
      touch-action: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    canvas {
      display: block;
      width: min(96vw, 1280px);
      height: min(80vh, 900px);
      border: 3px solid #333;
      background: #87ceeb;
    }

    #restart {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 20px;
      font-size: 18px;
      display: none;
      z-index: 30;
      margin: 0;
    }

    .joystick-base {
      position: fixed;
      width: 220px;
      height: 220px;
      border-radius: 50%;
      background: rgba(0, 122, 255, 0.2);
      touch-action: none;
      z-index: 12;
    }
    .joystick-knob {
      position: fixed;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: rgba(0, 122, 255, 0.9);
      touch-action: none;
      transform: translate(-50%, -50%);
      z-index: 13;
    }
    /* Style for all buttons */
button {
  font-size: 20px;       /* bigger text */
  padding: 12px 24px;    /* more clickable area */
  margin: 5px;           /* spacing between buttons */
  border-radius: 8px;    /* rounded corners */
  border: 2px solid #333;
  background-color: #4CAF50; /* green background */
  color: white;
  cursor: pointer;
  transition: background 0.2s ease;
}

button:hover {
  background-color: #45a049; /* slightly darker on hover */
}

    @media (max-width: 900px) {
      canvas {
        width: 100vw;
        height: 74dvh;
        border-left: 0;
        border-right: 0;
      }
      .joystick-base {
        width: 180px;
        height: 180px;
      }
      .joystick-knob {
        width: 58px;
        height: 58px;
      }
    }

  </style>
</head>
<body>
   <!-- <div style="display:flex; justify-content: center; position: absolute; bottom: 10px; width:100%;">
    <button onclick="window.location.href='index.html'">Game 1</button>
    <button onclick="window.location.href='index2.html'">Game 2</button>
    <button onclick="window.location.href='index3.html'">Game 3</button>
  </div> -->
  <div><h1>CATCH THE JERRY</h1></div>
    <div><h3>LEVEL 2 UNLOCK at Score = 5</h3></div>
    <div style="display:flex; justify-content: center;">
        <button onclick="window.location.href='index.html'">Home</button>
        <button onclick="window.location.href='index.html'">Other Games</button>
        <!-- <button onclick="window.location.href='index1.html'">Arrow keys</button>
        <button onclick="window.location.href='index2.html'">Joystick</button>
        <button onclick="window.location.href='index3.html'">Joystick + Fire</button>
        <button onclick="window.location.href='index4.html'">Long Stage</button>
        <button onclick="window.location.href='index5.html'">Jump + Fire</button>
        <button onclick="window.location.href='index6.html'">Jump + Stairs</button>
        <button onclick="window.location.href='index7.html'">Snake + Mario</button> -->
    </div>
  <canvas id="canvas"></canvas>
  <button id="restart">Restart</button>
 

  <!-- Movement joystick -->
  <div id="move-base"  class="joystick-base" style="bottom: 50px; left: 50px;"></div>
  <div id="move-knob"  class="joystick-knob"></div>

  <!-- Aim joystick -->
  <div id="aim-base"   class="joystick-base" style="bottom: 50px; right: 50px;"></div>
  <div id="aim-knob"   class="joystick-knob"></div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx    = canvas.getContext("2d");

    function resizeCanvas() {
      canvas.width  = Math.max(320, Math.floor(canvas.clientWidth));
      canvas.height = Math.max(220, Math.floor(canvas.clientHeight));
    }
    resizeCanvas();

    // game state
    let W = canvas.width, H = canvas.height;
    let x = W/2, y = H/2, vx = 0, vy = 0;
    let moveInput = { x: 0, y: 0 };
    let aimVector = { x: 1, y: 0 }, aimAngle = 0;
    const acceleration = 4200, friction = 0.92, bulletSpeed = 600;
    const maxSpeed = 900;
    const bullets = [];
    let lastBulletTime = 0;
    let coinx = 0, coiny = 0;
    const bombs = [];
    const bombSize = 70;
    const bombSpeed = 180;
    const bombSpawnInterval = 900;
    let lastBombSpawnTime = 0;
    let score = 0, gameOver = false;
    let t = Date.now();
    const keys = {};

    document.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (
        k === "arrowup" || k === "arrowdown" || k === "arrowleft" || k === "arrowright" ||
        k === "w" || k === "a" || k === "s" || k === "d" || k === " "
      ) {
        e.preventDefault();
      }
      keys[k] = true;
    }, { passive: false });

    document.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (
        k === "arrowup" || k === "arrowdown" || k === "arrowleft" || k === "arrowright" ||
        k === "w" || k === "a" || k === "s" || k === "d" || k === " "
      ) {
        e.preventDefault();
      }
      keys[k] = false;
    }, { passive: false });

    // images
    const playerImg = new Image();
    const coinImg   = new Image();
    const bombImg   = new Image();
    playerImg.src   = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS2oP3lWLmezhBAmuHvAwuaqRv6xVX0eApt7A&s';
    coinImg.src     = 'https://www.partysuppliesindia.com/cdn/shop/products/1_36_9f92dde3-d77d-4459-a21f-63744a94c836.jpg?v=1735574298&width=1500';
    bombImg.src     = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSrhGLUu7GF58R8WurYsZXGRwPSg1aER4LGrw&s';

    // restart button
    const restartButton = document.getElementById("restart");
    function positionRestartButtonAtCanvasCenter() {
      const rect = canvas.getBoundingClientRect();
      restartButton.style.left = `${rect.left + rect.width / 2}px`;
      restartButton.style.top = `${rect.top + rect.height / 2}px`;
      restartButton.style.transform = "translate(-50%, -50%)";
    }
    restartButton.onclick = () => {
      x = W/2; y = H/2; vx = vy = 0;
      bullets.length = 0;
      bombs.length = 0;
      score = 0; gameOver = false;
      lastBombSpawnTime = Date.now();
      spawnCoin();
      restartButton.style.display = "none";
      t = Date.now();
      draw();
    };

    // helpers to spawn
    function spawnCoin() {
      coinx = Math.random() * (W - 70);
      coiny = Math.random() * (H - 70);
    }
    function spawnBomb360() {
      const centerX = W / 2;
      const centerY = H / 2;
      const spawnRadius = Math.max(W, H) * 0.75;
      const angle = Math.random() * Math.PI * 2;
      const bx = centerX + Math.cos(angle) * spawnRadius;
      const by = centerY + Math.sin(angle) * spawnRadius;
      const targetX = x + 50;
      const targetY = y + 50;
      const dx = targetX - bx;
      const dy = targetY - by;
      const mag = Math.hypot(dx, dy) || 1;
      bombs.push({
        x: bx,
        y: by,
        vx: (dx / mag) * bombSpeed,
        vy: (dy / mag) * bombSpeed
      });
    }

    // universal joystick setup
    function setupJoystick(baseId, knobId, onMove) {
      const base = document.getElementById(baseId);
      const knob = document.getElementById(knobId);
      let activeId = null;
      const maxDist  = (base.offsetWidth - knob.offsetWidth) / 2;

      // center knob at start
      function resetKnob() {
        const rect = base.getBoundingClientRect();
        knob.style.left = (rect.left + base.offsetWidth/2) + "px";
        knob.style.top  = (rect.top  + base.offsetHeight/2) + "px";
      }
      resetKnob();

      // attach same listeners to both base & knob
      [base, knob].forEach(el => {
        el.addEventListener("touchstart", e => {
          e.preventDefault();
          if (activeId === null) {
            activeId = e.changedTouches[0].identifier;
          }
        }, { passive: false });

        el.addEventListener("touchmove", e => {
          e.preventDefault();
          for (let touch of e.changedTouches) {
            if (touch.identifier === activeId) {
              const rect = base.getBoundingClientRect();
              let dx = touch.clientX - (rect.left + base.offsetWidth/2);
              let dy = touch.clientY - (rect.top  + base.offsetHeight/2);
              const mag = Math.hypot(dx, dy);
              if (mag > maxDist) {
                dx = dx/mag * maxDist;
                dy = dy/mag * maxDist;
              }
              knob.style.left = (rect.left + base.offsetWidth/2 + dx) + "px";
              knob.style.top  = (rect.top  + base.offsetHeight/2 + dy) + "px";
              onMove(dx / maxDist, dy / maxDist);
            }
          }
        }, { passive: false });

        el.addEventListener("touchend", e => {
          for (let touch of e.changedTouches) {
            if (touch.identifier === activeId) {
              activeId = null;
              resetKnob();
              onMove(0, 0);
            }
          }
        });
      });
    }

    // movement stick
    setupJoystick("move-base", "move-knob", (dx, dy) => {
      moveInput.x = dx;
      moveInput.y = dy;
    });

    // aim stick
    setupJoystick("aim-base", "aim-knob", (dx, dy) => {
      if (dx !== 0 || dy !== 0) {
        aimVector.x = dx;
        aimVector.y = dy;
        aimAngle = Math.atan2(dy, dx);
      }
    });

    // init coin
    spawnCoin();

    function update(dt) {
      // Left joystick on desktop: WASD movement only
      const keyX = (keys["d"] ? 1 : 0) - (keys["a"] ? 1 : 0);
      const keyY = (keys["s"] ? 1 : 0) - (keys["w"] ? 1 : 0);
      const inputX = Math.abs(moveInput.x) > Math.abs(keyX) ? moveInput.x : keyX;
      const inputY = Math.abs(moveInput.y) > Math.abs(keyY) ? moveInput.y : keyY;

      // Right joystick on desktop: arrow keys control aim
      const aimKeyX = (keys["arrowright"] ? 1 : 0) - (keys["arrowleft"] ? 1 : 0);
      const aimKeyY = (keys["arrowdown"] ? 1 : 0) - (keys["arrowup"] ? 1 : 0);
      if (aimKeyX !== 0 || aimKeyY !== 0) {
        const mag = Math.hypot(aimKeyX, aimKeyY) || 1;
        aimVector.x = aimKeyX / mag;
        aimVector.y = aimKeyY / mag;
        aimAngle = Math.atan2(aimVector.y, aimVector.x);
      }

      // accelerate by stick input
      vx += inputX * acceleration * dt;
      vy += inputY * acceleration * dt;

      // apply friction
      vx *= friction;
      vy *= friction;
      const speed = Math.hypot(vx, vy);
      if (speed > maxSpeed) {
        vx = (vx / speed) * maxSpeed;
        vy = (vy / speed) * maxSpeed;
      }

      // move and clamp
      x = Math.max(0, Math.min(W-100, x + vx*dt));
      y = Math.max(0, Math.min(H-100, y + vy*dt));

      // shooting
      if (Date.now() - lastBulletTime > 150) {
        bullets.push({
          x: x + 50, y: y + 50,
          vx: aimVector.x * bulletSpeed,
          vy: aimVector.y * bulletSpeed
        });
        lastBulletTime = Date.now();
      }

      // update bullets & coin hits
      for (let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        if (b.x<0||b.x>W||b.y<0||b.y>H) bullets.splice(i,1);
        else if (b.x>=coinx && b.x<=coinx+70 && b.y>=coiny && b.y<=coiny+70) {
          score++;
          bullets.splice(i,1);
          spawnCoin();
        }
      }

      // 360-degree bomb logic (unlocks at score >= 5 only)
      if (score >= 5) {
        // ensure first bomb appears immediately when threshold is reached
        if (bombs.length === 0) {
          spawnBomb360();
          lastBombSpawnTime = Date.now();
        }
        if (Date.now() - lastBombSpawnTime >= bombSpawnInterval) {
          spawnBomb360();
          lastBombSpawnTime = Date.now();
        }

        for (let i = bombs.length - 1; i >= 0; i--) {
          const b = bombs[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;

          if (b.x < -bombSize * 2 || b.x > W + bombSize * 2 || b.y < -bombSize * 2 || b.y > H + bombSize * 2) {
            bombs.splice(i, 1);
            continue;
          }

          if (b.x <= x + 100 && x <= b.x + bombSize && b.y <= y + 100 && y <= b.y + bombSize) {
            gameOver = true;
            positionRestartButtonAtCanvasCenter();
            restartButton.style.display = "block";
            break;
          }
        }
      } else {
        bombs.length = 0;
      }

      // bullets vs bombs (optional defense)
      for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const bullet = bullets[bi];
        for (let i = bombs.length - 1; i >= 0; i--) {
          const b = bombs[i];
          if (
            bullet.x >= b.x &&
            bullet.x <= b.x + bombSize &&
            bullet.y >= b.y &&
            bullet.y <= b.y + bombSize
          ) {
            bullets.splice(bi, 1);
            bombs.splice(i, 1);
            break;
          }
        }
      }
    }

    function draw() {
      const dt = (Date.now() - t) / 1000;
      t = Date.now();
      if (!gameOver) update(dt);

      ctx.clearRect(0,0,W,H);
      ctx.font = "24px Arial";
      ctx.fillStyle = "black";
      ctx.fillText("Score: " + score, 20, 30);

      // coin & bombs
      ctx.drawImage(coinImg, coinx, coiny, 70, 70);
      bombs.forEach(b => ctx.drawImage(bombImg, b.x, b.y, bombSize, bombSize));

      // player
      ctx.save();
      ctx.translate(x+50, y+50);
      ctx.rotate(aimAngle);
      ctx.drawImage(playerImg, -50, -50, 100, 100);
      ctx.restore();

      // bullets
      ctx.fillStyle = "red";
      bullets.forEach(b => ctx.fillRect(b.x-5, b.y-5, 10,10));

      // game over overlay
      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = "white";
        ctx.font = "60px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", W/2, H/2);
      } else {
        requestAnimationFrame(draw);
      }
    }

    window.addEventListener("resize", () => {
      resizeCanvas();
      W = canvas.width;
      H = canvas.height;
      positionRestartButtonAtCanvasCenter();
      x = Math.max(0, Math.min(W - 100, x));
      y = Math.max(0, Math.min(H - 100, y));
    });

    playerImg.onload = () => {
      t = Date.now();
      lastBombSpawnTime = Date.now();
      draw();
    };
  </script>
</body>
</html>
