<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Super Jerry â€“ Double-Jump & High Leap</title>
  <style>
    html, body {
      margin:0; padding:0;
      user-select:none;
      display:flex; flex-direction:column;
      align-items:center;
      background:#eef;
    }
    #mobile-tilt-stage {
      width: 100%;
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    #game-container {
      position:relative;
      width:800px; height:600px;
      border:4px solid #333;
      overflow:hidden;
      background:#87ceeb;
      margin:20px auto;
    }
    #canvas {
      width:800px; height:600px; display:block;
    }
    #restart {
      position:absolute; top:50%; left:50%;
      transform:translate(-50%,-50%);
      padding:10px 20px; font-size:18px;
      display:none; z-index:10;
    }
    #controls {
      width:800px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:10px;
    }
    #joystick-container {
      width:240px; height:240px;
      border-radius:50%;
      background:rgba(0,0,0,0.25);
      touch-action:none;
      position:relative;
    }
    #joystick-thumb {
      position:absolute;
      width:80px; height:80px;
      border-radius:50%;
      background:rgba(0,0,0,0.5);
      left:calc(50% - 40px);
      top:calc(50% - 40px);
      transition:left .1s, top .1s;
    }
    #fire-button {
      width:80px; height:80px;
      border-radius:50%;
      background:rgba(0,0,255,0.6);
      color:white; font-size:14px;
      border:none; touch-action:none;
    }
    /* Style for all buttons */
button {
  font-size: 20px;       /* bigger text */
  padding: 12px 24px;    /* more clickable area */
  margin: 5px;           /* spacing between buttons */
  border-radius: 8px;    /* rounded corners */
  border: 2px solid #333;
  background-color: #4CAF50; /* green background */
  color: white;
  cursor: pointer;
  transition: background 0.2s ease;
}

button:hover {
  background-color: #45a049; /* slightly darker on hover */
}

    @media (orientation: portrait) {
      html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      body {
        display: block;
      }

      #mobile-tilt-stage {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 100vh;
        height: 100vw;
        transform: translate(-50%, -50%) rotate(90deg);
        transform-origin: center center;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        padding: 0.5rem;
      }

      h1, h3, #top-nav {
        display: none;
      }

      #game-container {
        width: 95%;
        max-width: 760px;
        height: auto;
        aspect-ratio: 4 / 3;
        margin: 0 auto;
      }

      #canvas {
        width: 100%;
        height: 100%;
      }

      #controls {
        width: 95%;
        max-width: 760px;
        margin-top: 8px;
        margin-bottom: 0;
      }

      #joystick-container {
        width: 170px;
        height: 170px;
      }

      #joystick-thumb {
        width: 62px;
        height: 62px;
        left: calc(50% - 31px);
        top: calc(50% - 31px);
      }

      #fire-button {
        width: 82px;
        height: 82px;
        font-size: 13px;
        padding: 0;
      }
    }

  </style>
</head>
<body>
  <div id="mobile-tilt-stage">
  <h1>SUPER JERRY RUNNER</h1>
  <h3>Now with High Double-Jump!</h3>
  <div id="top-nav" style="display:flex; gap:10px; margin-bottom:10px;">
    <button onclick="window.location.href='index.html'">Arrow keys</button>
    <button onclick="window.location.href='index.html'">Other Games</button>
    <!-- <button onclick="window.location.href='index1.html'">Arrow keys</button>
    <button onclick="window.location.href='index2.html'">Joystick</button>
    <button onclick="window.location.href='index3.html'">Joystick + Fire</button>
    <button onclick="window.location.href='index4.html'">Long Stage</button>
    <button onclick="window.location.href='index5.html'">Jump + Fire</button>
    <button onclick="window.location.href='index6.html'">Jump + Stairs</button>
    <button onclick="window.location.href='index7.html'">Snake + Mario</button> -->
  </div>
  <div id="game-container">
    <canvas id="canvas" width="800" height="600"></canvas>
    <button id="restart">Restart</button>
  </div>

  <div id="controls">
    <div id="joystick-container"><div id="joystick-thumb"></div></div>
    <button id="fire-button">FIRE</button>
  </div>
  </div>

  <script>
  window.onload = () => {
    const canvas     = document.getElementById("canvas"),
          ctx        = canvas.getContext("2d"),
          restartBtn = document.getElementById("restart"),
          fireBtn    = document.getElementById("fire-button"),
          base       = document.getElementById("joystick-container"),
          thumb      = document.getElementById("joystick-thumb");

    // VIEWPORT & WORLD
    const viewW = 800, viewH = 600;
    const worldW = 5000, worldH = viewH;
    const groundH = 50, groundY = worldH - groundH;

    // PLAYER
    const playerSize = 50;
    let x = 100, y = groundY - playerSize;
    let vx = 0, vy = 0;
    let grounded = false, jumpsRemaining = 2, gameOver = false;

    // PHYSICS
    const accel             = 2000;
    const gravity           = 2000;
    const jumpVelocity      = 700;   // higher jump
    const joyBoost          = 1.5;
    const runMultiplier     = 1.8;
    const horizontalFric    = 0.85;   // only x-damping
    const verticalFric      = 1.0;    // no vertical friction

    // COINS
    const coinSize = 35, coins = [], numCoins = 10;

    // OBSTACLES (bombs)
    const obstacleSize  = coinSize;
    const groundObs     = [];
    const fallingObs    = [];
    const baseGroundObs = 8;
    const baseFallingObs = 8;
    const maxGroundObs = 22;
    const maxFallingObs = 18;

    // FLOATING BARS (platforms)
    const floatingBars = [];
    const baseFloatingBars = 28;
    const minFloatingBars = 10;
    const barH = 16;
    const barMinW = 180;
    const barMaxW = 280;

    // BULLETS
    const bullets      = [];
    const bulletSpeed  = 1000;
    const bulletSize   = 8;

    // SCORE
    let score = 0;
    let level = 1;

    // INPUT
    const keys = {};
    const blockedKeys = new Set([" ", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
    document.addEventListener("keydown", e => {
      if (blockedKeys.has(e.key)) e.preventDefault();
      keys[e.key.toLowerCase()] = true;
      if ((e.key === "w" || e.key === "ArrowUp") && jumpsRemaining > 0) {
        vy = -jumpVelocity;
        jumpsRemaining--;
        grounded = false;
      }
      if (e.code === "Space") shootBullet();
    });
    document.addEventListener("keyup", e => {
      if (blockedKeys.has(e.key)) e.preventDefault();
      keys[e.key.toLowerCase()] = false;
    });

    // JOYSTICK
    let joyX = 0, joyY = 0;
    let joystickTouchId = null;
    let stickR = base.clientWidth / 2;
    let thumbR = thumb.clientWidth / 2;
    let maxDisp = Math.max(1, stickR - thumbR);
    function recalcJoystickMetrics() {
      stickR = base.clientWidth / 2;
      thumbR = thumb.clientWidth / 2;
      maxDisp = Math.max(1, stickR - thumbR);
      handleEnd();
    }
    function setJoystickFromTouch(t) {
      const r = base.getBoundingClientRect();
      let dx = t.clientX - (r.left + stickR),
          dy = t.clientY - (r.top  + stickR),
          d  = Math.hypot(dx, dy);
      if (d > maxDisp) { dx = dx / d * maxDisp; dy = dy / d * maxDisp; }
      thumb.style.left = `${stickR + dx - thumbR}px`;
      thumb.style.top  = `${stickR + dy - thumbR}px`;
      joyX = dx / maxDisp;
      joyY = dy / maxDisp;
    }
    base.addEventListener("touchstart", e => {
      e.preventDefault();
      if (joystickTouchId !== null) return;
      const t = e.changedTouches[0];
      if (!t) return;
      joystickTouchId = t.identifier;
      setJoystickFromTouch(t);
    }, {passive:false});
    base.addEventListener("touchmove",  e=>{
      e.preventDefault();
      if (joystickTouchId === null) return;
      const t = Array.from(e.touches).find(tch => tch.identifier === joystickTouchId);
      if (!t) return;
      setJoystickFromTouch(t);
    }, {passive:false});
    base.addEventListener("touchend", handleEnd);
    base.addEventListener("touchcancel", handleEnd);
    function handleEnd(e){
      if (joystickTouchId !== null && e) {
        const released = Array.from(e.changedTouches).some(t => t.identifier === joystickTouchId);
        if (!released) return;
      }
      joystickTouchId = null;
      thumb.style.left = `${stickR - thumbR}px`;
      thumb.style.top  = `${stickR - thumbR}px`;
      joyX = joyY = 0;
    }
    window.addEventListener("resize", recalcJoystickMetrics);
    recalcJoystickMetrics();

    // FIRE BUTTON
    fireBtn.addEventListener("touchstart", e=>{e.preventDefault(); shootBullet()});
    fireBtn.addEventListener("mousedown", e=>{e.preventDefault(); shootBullet()});

    function shootBullet(){
      let nearest, md=Infinity;
      const px = x+playerSize/2, py = y+playerSize/2;
      [...groundObs, ...fallingObs].forEach(ob=>{
        const ox = ob.x + (ob.size||obstacleSize)/2;
        const oy = ob.y + (ob.size||obstacleSize)/2;
        const d2 = (ox-px)**2 + (oy-py)**2;
        if (d2 < md){ md=d2; nearest=ob; }
      });
      let angle = 0;
      if (nearest){
        const ox = nearest.x + (nearest.size||obstacleSize)/2;
        const oy = nearest.y + (nearest.size||obstacleSize)/2;
        angle = Math.atan2(oy-py, ox-px);
      }
      bullets.push({
        x:px, y:py,
        vx:Math.cos(angle)*bulletSpeed,
        vy:Math.sin(angle)*bulletSpeed
      });
    }

    // RESTART
    restartBtn.onclick = resetGame;
    function resetGame(){
      x=100; y=groundY-playerSize;
      vx=vy=0;
      grounded=true;
      jumpsRemaining=2;
      gameOver=false;
      score=0;
      level=1;
      bullets.length=0;
      initEntities();
      restartBtn.style.display="none";
      lastTime=Date.now();
      requestAnimationFrame(draw);
    }

    function getLevelConfig(levelNo){
      return {
        groundBombs: Math.min(baseGroundObs + (levelNo - 1), maxGroundObs),
        fallingBombs: Math.min(baseFallingObs + Math.floor((levelNo - 1) / 2), maxFallingObs),
        floatingBarCount: Math.max(baseFloatingBars - Math.floor((levelNo - 1) / 2), minFloatingBars)
      };
    }

    function advanceLevel(){
      level++;
      x = 20;
      y = groundY - playerSize;
      vx = 0;
      vy = 0;
      grounded = true;
      jumpsRemaining = 2;
      bullets.length = 0;
      initEntities();
    }

    // INIT ALL COINS & OBSTACLES FOR CURRENT LEVEL
    function initEntities(){
      const cfg = getLevelConfig(level);
      coins.length=groundObs.length=fallingObs.length=floatingBars.length=0;
      for(let i=0;i<numCoins;i++){
        coins.push({
          x:rand(300, worldW - coinSize -200),
          y:groundY - coinSize - rand(0,80)
        });
      }
      for(let i=0;i<cfg.groundBombs;i++){
        groundObs.push({
          x:rand(220, worldW - obstacleSize -200),
          y:groundY - obstacleSize,
          hp:5
        });
      }
      for(let i=0;i<cfg.fallingBombs;i++){
        const size=rand(30,60);
        fallingObs.push({
          x:rand(300, worldW-300),
          y:-size,
          vy:rand(200,400),
          size, hp:3
        });
      }
      // Create floating bars across the whole world, above bombs/ground.
      // Sequential placement keeps a playable jump path.
      let cursorX = 140;
      for(let i=0; i<cfg.floatingBarCount && cursorX < worldW - 200; i++){
        const w = rand(barMinW, barMaxW);
        const baseX = cursorX;
        const moveRange = rand(120, 220);
        floatingBars.push({
          x: baseX,
          y: groundY - rand(120, 240),
          w,
          h: barH,
          vx: rand(55, 110) * (Math.random() < 0.5 ? -1 : 1),
          minX: Math.max(0, baseX - moveRange),
          maxX: Math.min(worldW - w, baseX + moveRange)
        });
        cursorX += rand(140, 230);
      }
    }

    // HELPERS
    function rand(min,max){ return Math.random()*(max-min)+min; }
    function clamp(v,lo,hi){ return v<lo?lo:v>hi?hi:v; }
    function overlap(x1,y1,w1,h1,x2,y2,w2,h2){
      return x1<=x2+w2 && x2<=x1+w1 && y1<=y2+h2 && y2<=y1+h1;
    }
    function triggerGameOver(){
      if (gameOver) return;
      gameOver = true;
      restartBtn.style.display = "block";
    }

    // MAIN LOOP
    let lastTime = Date.now();
    function draw(){
      const now = Date.now(), dt=(now-lastTime)/1000;
      lastTime=now;
      const prevY = y;

      // HORIZONTAL
      let ax = 0;
      if (keys["d"] || keys["arrowright"]) ax += accel*runMultiplier;
      if (keys["a"] || keys["arrowleft"])  ax -= accel*runMultiplier;
      ax += joyX*accel*joyBoost*runMultiplier;
      vx += ax*dt;
      vx *= horizontalFric;

      // VERTICAL (jump/fast-fall/gravity)
      if (joyY < -0.5 && jumpsRemaining>0){
        vy = -jumpVelocity;
        jumpsRemaining--;
        grounded=false;
      }
      if (joyY > 0.5 && !grounded){
        vy += gravity*dt*1.5;
      }
      vy += gravity*dt;
      vy *= verticalFric;

      // POSITION & WRAP
      x += vx*dt; y += vy*dt;
      if (x <= 0){
        x = 0;
        vx = Math.max(0, vx);
      }
      if (x + playerSize >= worldW){
        advanceLevel();
      }

      // MOVE FLOATING BARS (left-right)
      floatingBars.forEach(bar => {
        bar.x += bar.vx * dt;
        if (bar.x <= bar.minX){
          bar.x = bar.minX;
          bar.vx *= -1;
        } else if (bar.x >= bar.maxX){
          bar.x = bar.maxX;
          bar.vx *= -1;
        }
      });

      // FLOATING BAR COLLISION (landing from above)
      grounded = false;
      for (let i = 0; i < floatingBars.length; i++){
        const bar = floatingBars[i];
        const prevBottom = prevY + playerSize;
        const currBottom = y + playerSize;
        const onTopPath = prevBottom <= bar.y && currBottom >= bar.y;
        const withinX = (x + playerSize) > bar.x && x < (bar.x + bar.w);
        if (vy >= 0 && onTopPath && withinX){
          y = bar.y - playerSize;
          vy = 0;
          grounded = true;
          jumpsRemaining = 2;
          break;
        }
      }

      // GROUND COLLISION & reset jumps
      if (!grounded && y + playerSize >= groundY){
        y = groundY - playerSize;
        vy = 0;
        grounded = true;
        jumpsRemaining = 2;    // reset double-jump
      }

      // CAMERA
      const camX = clamp(x + playerSize/2 - viewW/2, 0, worldW - viewW);
      const parallaxFactor = 0.3;
      const gridSize = 50;

      // CLEAR
      ctx.clearRect(0,0,viewW,viewH);

      // MOVING BACKGROUND GRID (parallax)
      const bgOffset = camX * parallaxFactor;
      ctx.save();
      ctx.translate(-bgOffset, 0);
      ctx.strokeStyle = "rgba(255,255,255,0.28)";
      ctx.lineWidth = 1;
      for (let gx = 0; gx <= viewW + gridSize; gx += gridSize){
        ctx.beginPath();
        ctx.moveTo(gx, 0);
        ctx.lineTo(gx, viewH);
        ctx.stroke();
      }
      for (let gy = 0; gy <= viewH + gridSize; gy += gridSize){
        ctx.beginPath();
        ctx.moveTo(0, gy);
        ctx.lineTo(viewW + gridSize, gy);
        ctx.stroke();
      }
      ctx.restore();

      // DRAW WORLD
      ctx.save();
      ctx.translate(-camX,0);

      // GROUND
      ctx.fillStyle="#654321";
      ctx.fillRect(0, groundY, worldW, groundH);

      // FLOATING BARS
      floatingBars.forEach(bar=>{
        ctx.fillStyle = "#6b4f2a";
        ctx.fillRect(bar.x, bar.y, bar.w, bar.h);
        ctx.strokeStyle = "rgba(0,0,0,0.25)";
        ctx.strokeRect(bar.x, bar.y, bar.w, bar.h);
      });

      // COINS
      coins.forEach(c=>{
        ctx.drawImage(coinImg,c.x,c.y,coinSize,coinSize);
        if (overlap(c.x,c.y,coinSize,coinSize, x,y,playerSize,playerSize)){
          score++;
          c.x = rand(120, worldW - coinSize - 120);
          c.y = groundY-coinSize-rand(0,80);
        }
      });

      // GROUND BOMBS
      groundObs.forEach((ob,oi)=>{
        ctx.drawImage(bombImg,ob.x,ob.y,obstacleSize,obstacleSize);
        if (overlap(ob.x, ob.y, obstacleSize, obstacleSize, x, y, playerSize, playerSize)){
          triggerGameOver();
        }
      });

      // FALLING BOMBS
      fallingObs.forEach((fo,fi)=>{
        fo.y += fo.vy*dt;
        ctx.drawImage(bombImg, fo.x, fo.y, fo.size, fo.size);
        if (fo.y > worldH+fo.size){
          fallingObs[fi] = {
            x:rand(120,worldW-160),
            y:-fo.size,
            vy:fo.vy,size:fo.size,hp:3
          };
        }
        if (overlap(fo.x, fo.y, fo.size, fo.size, x, y, playerSize, playerSize)){
          triggerGameOver();
        }
      });

      // BULLETS & COLLISIONS
      ctx.fillStyle="yellow";
      for(let bi=bullets.length-1; bi>=0; bi--){
        const b=bullets[bi];
        b.x+=b.vx*dt; b.y+=b.vy*dt;
        ctx.beginPath();
        ctx.arc(b.x,b.y,bulletSize,0,2*Math.PI);
        ctx.fill();

        // off-screen?
        if (b.x<camX-50||b.x>camX+viewW+50||b.y<-50||b.y>viewH+50){
          bullets.splice(bi,1); continue;
        }

        // vs ground bombs
        groundObs.forEach((ob,oi)=>{
          if (overlap(b.x-bulletSize,b.y-bulletSize,bulletSize*2,bulletSize*2,
                      ob.x,ob.y,obstacleSize,obstacleSize)){
            ob.hp--;
            bullets.splice(bi,1);
            if (ob.hp<=0) groundObs.splice(oi,1);
          }
        });
        // vs falling bombs
        fallingObs.forEach((fo,fi)=>{
          if (overlap(b.x-bulletSize,b.y-bulletSize,bulletSize*2,bulletSize*2,
                      fo.x,fo.y,fo.size,fo.size)){
            fo.hp--;
            bullets.splice(bi,1);
            if (fo.hp<=0) fallingObs.splice(fi,1);
          }
        });
      }

      // PLAYER
      ctx.drawImage(playerImg,x,y,playerSize,playerSize);
      ctx.restore();

      // UI
      ctx.fillStyle="black";
      ctx.font="25px Arial";
      ctx.textAlign="left";
      ctx.fillText("Score: "+score,10,30);
      ctx.fillText("Level: "+level,10,60);

      if (!gameOver) requestAnimationFrame(draw);
    }

    // LOAD & START
    const playerImg = new Image(),
          coinImg   = new Image(),
          bombImg   = new Image();
    const assets = [playerImg, coinImg, bombImg];
    let loadedAssets = 0;

    const startWhenReady = () => {
      loadedAssets++;
      if (loadedAssets === assets.length) {
        initEntities();
        lastTime = Date.now();
        draw();
      }
    };

    assets.forEach(img => {
      img.onload = startWhenReady;
      img.onerror = startWhenReady;
    });

    playerImg.src = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS2oP3lWLmezhBAmuHvAwuaqRv6xVX0eApt7A&s';
    coinImg.src   = 'https://www.partysuppliesindia.com/cdn/shop/products/1_36_9f92dde3-d77d-4459-a21f-63744a94c836.jpg?v=1735574298&width=1500';
    bombImg.src   = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSrhGLUu7GF58R8WurYsZXGRwPSg1aER4LGrw&s';
  };
  </script>
</body>
</html>
